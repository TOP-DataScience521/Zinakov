АТРИБУТЫ КЛАССОВ И ЭКЗЕМПЛЯРОВ

  ==========  1  ==========  

Написать класс с именем Tetrahedron, который описывает правильный тетраэдр.


Поля класса отсутствуют.

Атрибуты экземпляра:
    edge: float - длина ребра

Методы:
    __init__()
        конструктор класса
    
    surface() -> float
        вычисляет площадь поверхности
    
    volume() -> float
        вычисляет объём тела

Параметры конструктора:
    edge: float

Информация о правильном тетраэдре:
    https://mnogogranniki.ru/tetraedr.html

Написанный класс необходимо протестировать.
Пример теста:
    >>> t1 = Tetrahedron(5)
    >>> t1.edge
    5.0
    >>> t1.surface()
    43.30127018922193
    >>> t1.volume()
    14.731391274719739
    >>> 
    >>> t1.edge = 6
    >>> t1.surface()
    62.35382907247958



  ==========  2  ==========  

Написать класс с именем PowerMeter, который описывает двухтарифный счётчик потреблённой электрической мощности.


Поля класса отсутствуют.

Атрибуты экземпляра:
    tariff1: decimal.Decimal - первый тариф
    tariff2: decimal.Decimal - второй тариф
    tariff2_starts: datetime.time - время начала действия второго тарифа
    tariff2_ends: datetime.time - время окончания действия второго тарифа
    power: decimal.Decimal - суммарная потреблённая мощность
    charges: dict[datetime.date, decimal.Decimal] - начисления за каждый месяц согласно тарифным планам
    
    Диапазон времени, задаваемый значениями tariff2_starts и tariff2_ends, устанавливает безотносительно даты только время суток, в течение которого действует второй тариф
    
    Ключами словаря charges должны являться первые числа каждого очередного месяца, представленные типом datetime.date
    
    Значениями словаря charges должны являться значения стоимости потреблённой мощности в течение соответствующего месяца — как и любая финансовая величина, эти значения используют тип вещественных чисел с фиксированной точкой и округляются до двух десятичных знаков

Методы:
    __init__()
        конструктор класса
    
    __repr__()
        машиночитаемое строковое представление
    
    __str__()
        человекочитаемое строковое представление
    
    meter() -> decimal.Decimal
        принимает значение потреблённой мощности, вычисляет и возвращает стоимость согласно тарифному плану, действующему в текущий момент
    
    Форматы строковых представлений необходимо взять из примеров ниже.
    
    Обратите внимание, что метод meter() вычисленное значение стоимости должен добавить к сохранённому значению в атрибуте charges по ключу, который формируется на основании текущей даты. При этом метод meter() возвращает стоимость, соответствующую переданному значению потреблённой мощности, а не накопленную за весь месяц.

Параметры конструктора:
    tariff1: numbers.Number = ...
    tariff2: numbers.Number = ...
    tariff2_starts: datetime.time = ...
    tariff2_ends: datetime.time = ...
    
    Обратите внимание, что в качестве аргументов для тарифов могут быть переданы числа произвольного типа, в то время как в атрибут экземпляра должен быть записан именно объект типа decimal.Decimal
    
    = ... в данном контексте указывает на необходимость подстановки значения по умолчанию

Параметры meter:
    power: numbers.Number

Написанный класс необходимо протестировать.
Пример теста:
    >>> pm1 = PowerMeter()
    >>> 
    >>> pm1.meter(2)
    Decimal('13.00')
    >>> pm1.meter(1.2)
    Decimal('7.80')
    >>> 
    >>> pm1
    <PowerMeter: 3.2 кВт/ч>
    >>> print(pm1)
    (Jul) 20.80



  ==========  3  ==========  

Написать класс с именем ChessKing, который описывает шахматную фигуру короля.


Поля класса:
    files: dict[str, int] - соответствие между буквой, обозначающей вертикаль шахматной доски, и числом
    ranks: dict[str, int] - соответствие между строковым представлением числа, обозначающего горизонталь шахматной доски, и числом

Атрибуты экземпляра:
    color: str - цвет фигуры
    square: str - поле шахматной доски, на котором в данный момент находится фигура

Методы:
    __init__()
        конструктор класса
    
    __repr__()
        машиночитаемое строковое представление
    
    __str__()
        человекочитаемое строковое представление
    
    is_turn_valid() -> bool
        принимает на вход строку нового поля и проверяет, возможен ли для данной фигуры ход с текущего поля на новое
    
    turn() -> None
        принимает на вход строку нового поля и выполняет ход, выбрасывает ValueError в случае невозможности выполнить ход
    
    Машиночитаемое и человекочитаемое строковые представления для данного класса аналогичны, их формат необходимо взять из примера ниже
    
    Выполнение хода в данном случае осуществляется с помощью перезаписи значения атрибута square. Возможное наличие фигуры на поле назначения игнорировать
    
    Выброс исключения осуществляется с помощью инструкции raise:
    >>> raise TypeError
    ...
    TypeError

Параметры конструктора:
    color: str = 'white'
    square: str = None
    
    В случае, если аргумент для square не передан, то в соответствующий атрибут экземпляра должна быть записана начальная позиция фигуры соответствующего цвета

Параметры is_turn_valid():
    new_square: str

Параметры turn():
    new_square: str

Написанный класс необходимо протестировать.
Пример теста:
    >>> wk = ChessKing()
    >>> wk.color
    'white'
    >>> wk.square
    'e1'
    >>>
    >>> wk.turn('e2')
    >>> wk
    'WK: e2'
    >>>
    >>> wk.turn('d4')
    ... 
    ValueError
    >>> 
    >>> bk = ChessKing('black')
    >>> print(bk)
    BK: e8



  ==========  4  ==========  

Написать класс с именем CountableNouns, который предоставляет интерфейс для работы с файловой базой существительных.


Поля класса:
    db_path: pathlib.Path - путь к файлу с базой существительных
    words: dict[str, tuple[str, str]] - соответствие между существительным в единственном числе и кортежем из двух словоформ/слов во множественном числе, согласующихся с числительными "два" и "пять"
    
    Файл с тестовой базой существительных words.csv находится в каталоге домашнего задания. Для работы с файлами формата CSV используются функции reader() и writer() из модуля стандартной библиотеки csv. Подробнее об использовании этих функций в документации:
        https://docs.python.org/3/library/csv.html#module-contents
                
        При вызове функции writer() передайте значение '\n' в ключевой параметр lineterminator
    
    Чтение из файла с базой существительных и запись значений в словарь words должно осуществляться во время создания объекта класса

Атрибуты экземпляра отсутствуют.

Методы:
    {class} pick() -> str
        принимает в качестве аргументов число и существительное для согласования в единственном числе, возвращает согласованное с переданным числом существительное
    
    {class} save_words() -> None
        запрашивает в stdin у пользователя два или три слова согласующихся с числительными, добавляет полученные значения в поле класса words и дописывает их в файл с базой существительных
    
    {class} в данном контексте указывает на необходимость определения классового метода
    
    В случае, если переданное в метод pick() существительное отсутствует в базе, должен быть вызван метод save_words() с передачей последнему этого существительного в качестве аргумента

Параметры pick():
    number: int
    word: str

Параметры save_words():
    word1: str = None
    
    При вызове данного метода с передачей слова в единственном числе достаточно запросить два слова для согласования с числительными "два" и "пять"
    
    Данный метод также может быть вызван отдельно, без передачи аргумента: в этом случае метод должен запросить все три слова для согласования с числительными "один", "два" и "пять" (см. тест ниже)

Написанный класс необходимо протестировать.
Пример теста:
    >>> CountableNouns.words
    {'год': ('года', 'лет'), 'месяц': ('месяца', 'месяцев'), 'день': ('дня', 'дней')}
    >>> 
    >>> CountableNouns.pick(22, 'год')
    'года'
    >>> CountableNouns.pick(365, 'день')
    'дней'
    >>> 
    >>> CountableNouns.pick(21, 'попугай')
    'попугай'
    >>> CountableNouns.pick(22, 'попугай')
    существительное "попугай" отсутствует в базе
      введите слово, согласующееся с числительным "два": попугая
      введите слово, согласующееся с числительным "пять": попугаев
    >>>
    >>> CountableNouns.words
    {'год': ('года', 'лет'), 'месяц': ('месяца', 'месяцев'), 'день': ('дня', 'дней'), 'попугай': ('попугая', 'попугаев')}
    >>>
    >>> CountableNouns.save_words()
     введите слово, согласующееся с числительным "один": капля
      введите слово, согласующееся с числительным "два": капли
      введите слово, согласующееся с числительным "пять": капель
    >>>
    >>> print(CountableNouns.db_path.read_text(encoding='utf-8'))
    год,года,лет
    месяц,месяца,месяцев
    день,дня,дней
    попугай,попугая,попугаев
    капля,капли,капель



  =========================

Каждый класс должен быть документирован. 
Каждый метод кроме специальных (встроенных) должен быть документирован.

Помимо перечисленных в каждой задаче обязательных атрибутов классов и экземпляров возможно добавление собственных вспомогательных атрибутов и методов.

Работа классов тестируется в режиме инспекции файла с кодом.
Ввод и вывод в стандартные потоки результатов тестов копируются.
Копия в виде комментария помещается в конец файла с кодом задачи.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении всех частей задания со ссылкой на репозиторий.

Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.